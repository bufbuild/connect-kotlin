// Copyright 2022-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package build.buf.protocgen.connect

import build.buf.connect.BidirectionalStreamInterface
import build.buf.connect.ClientOnlyStreamInterface
import build.buf.connect.MethodSpec
import build.buf.connect.ProtocolClientInterface
import build.buf.connect.ResponseMessage
import build.buf.connect.ServerOnlyStreamInterface
import build.buf.protocgen.connect.internal.CodeGenerator
import build.buf.protocgen.connect.internal.Plugin
import com.google.protobuf.DescriptorProtos
import com.google.protobuf.compiler.PluginProtos
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName

/*
 * These are constants since build.buf.connect.Headers and build.buf.connect.http.Cancelable
 * are type aliases which doesn't have an underlying class for KotlinPoet to know what to do.
 *
 * The conventional and nicer way is to use the class type: Headers::class.asClassType() but
 * type aliasing does not allow for that.
 *
 * Instead, this is the way to reference these objects for now. If there is ever a desire to
 * move off of type aliases, this can be changed without user API breakage.
 */
private val HEADERS_CLASS_NAME = ClassName.bestGuess("build.buf.connect.Headers")
private val CANCELABLE_CLASS_NAME = ClassName.bestGuess("build.buf.connect.http.Cancelable")

class Generator : CodeGenerator {
    private val compiledTypes = mutableMapOf<String, String>()

    override fun generate(
        request: PluginProtos.CodeGeneratorRequest,
        descriptorSource: Plugin.DescriptorSource,
        response: Plugin.Response
    ) {
        for (file in request.protoFileList) {
            val packageName = if (file.options.javaPackage.isNullOrBlank()) file.`package` else file.options.javaPackage
            for (messageType in file.messageTypeList) {
                compiledTypes.put(messageType.name, packageName)
            }
            for (enumType in file.enumTypeList) {
                compiledTypes.put(enumType.name, packageName)
            }
        }
        for (file in request.protoFileList) {
            if (file.serviceList.isEmpty()) {
                // Avoid generating files with no service definitions.
                continue
            }
            val fileMap = parseFile(file)
            for ((className, fileSpec) in fileMap) {
                response.addFile("${className.canonicalName.packageToDirectory()}.kt", fileSpec.toString())
            }
        }
    }

    private fun parseFile(file: DescriptorProtos.FileDescriptorProto): Map<ClassName, FileSpec> {
        val fileSpecs = mutableMapOf<ClassName, FileSpec>()
        for (service in file.serviceList) {
            val packageName = if (file.options.javaPackage.isNullOrBlank()) file.`package` else file.options.javaPackage
            val interfaceFileSpec = FileSpec.builder(packageName, file.name)
                // Manually import `method()` since it is a method and not a class.
                .addFileComment("Code generated by connect-kotlin. DO NOT EDIT.\n")
                .addFileComment("\n")
                .addFileComment("Source: ${file.name}\n")
                .addType(serviceClientInterface(packageName, service))
                .build()
            fileSpecs.put(serviceClientInterfaceClassName(packageName, service), interfaceFileSpec)

            val implementationFileSpec = FileSpec.builder(packageName, file.name)
                // Manually import `method()` since it is a method and not a class.
                .addImport(MethodSpec::class.java.packageName, "MethodSpec")
                .addFileComment("Code generated by connect-kotlin. DO NOT EDIT.\n")
                .addFileComment("\n")
                .addFileComment("Source: ${file.name}\n")
                // Set the file package for the generated methods.
                .addType(serviceClientImplementation(file.`package`, packageName, service))
                .build()
            fileSpecs.put(serviceClientImplementationClassName(packageName, service), implementationFileSpec)
        }
        return fileSpecs
    }

    private fun serviceClientInterface(
        packageName: String,
        service: DescriptorProtos.ServiceDescriptorProto
    ): TypeSpec {
        val interfaceBuilder = TypeSpec.interfaceBuilder(serviceClientInterfaceClassName(packageName, service))
        val functionSpecs = interfaceMethods(
            service.methodList
        )
        return interfaceBuilder
            .addFunctions(functionSpecs)
            .build()
    }

    private fun interfaceMethods(
        methods: List<DescriptorProtos.MethodDescriptorProto>
    ): List<FunSpec> {
        val functions = mutableListOf<FunSpec>()
        val headerParameterSpec = ParameterSpec.builder("headers", HEADERS_CLASS_NAME)
            .defaultValue("%L", "emptyMap()")
            .build()
        for (method in methods) {
            val inputClassName = ClassName.bestGuess(className(method.inputType))
            val outputClassName = ClassName.bestGuess(className(method.outputType))
            if (method.hasClientStreaming() && method.hasServerStreaming()) {
                val streamingBuilder = FunSpec.builder(method.name.lowerCamelCase())
                    .addModifiers(KModifier.ABSTRACT)
                    .addModifiers(KModifier.SUSPEND)
                    .addParameter(headerParameterSpec)
                    .returns(
                        BidirectionalStreamInterface::class.asClassName()
                            .parameterizedBy(inputClassName, outputClassName)
                    )
                functions.add(streamingBuilder.build())
            } else if (method.hasServerStreaming()) {
                val serverStreamingFunction = FunSpec.builder(method.name.lowerCamelCase())
                    .addModifiers(KModifier.ABSTRACT)
                    .addModifiers(KModifier.SUSPEND)
                    .addParameter(headerParameterSpec)
                    .returns(
                        ServerOnlyStreamInterface::class.asClassName().parameterizedBy(inputClassName, outputClassName)
                    )
                    .build()
                functions.add(serverStreamingFunction)
            } else if (method.hasClientStreaming()) {
                val clientStreamingFunction = FunSpec.builder(method.name.lowerCamelCase())
                    .addModifiers(KModifier.ABSTRACT)
                    .addModifiers(KModifier.SUSPEND)
                    .addParameter(headerParameterSpec)
                    .returns(
                        ClientOnlyStreamInterface::class.asClassName().parameterizedBy(inputClassName, outputClassName)
                    )
                    .build()
                functions.add(clientStreamingFunction)
            } else {
                val unarySuspendFunction = FunSpec.builder(method.name.lowerCamelCase())
                    .addModifiers(KModifier.ABSTRACT)
                    .addModifiers(KModifier.SUSPEND)
                    .addParameter("request", inputClassName)
                    .addParameter(headerParameterSpec)
                    .returns(ResponseMessage::class.asClassName().parameterizedBy(outputClassName))
                    .build()
                functions.add(unarySuspendFunction)
            }
        }
        return functions
    }

    private fun serviceClientImplementation(
        packageName: String,
        javaPackageName: String,
        service: DescriptorProtos.ServiceDescriptorProto
    ): TypeSpec {
        // The javaPacakgeName is used instead of the package name for imports and code references.
        val classBuilder = TypeSpec.classBuilder(serviceClientImplementationClassName(javaPackageName, service))
            .addSuperinterface(serviceClientInterfaceClassName(javaPackageName, service))
            .primaryConstructor(
                FunSpec.constructorBuilder()
                    .addParameter("client", ProtocolClientInterface::class)
                    .build()
            )
            .addProperty(
                PropertySpec.builder("client", ProtocolClientInterface::class, KModifier.PRIVATE)
                    .initializer("client")
                    .build()
            )
        val functionSpecs = implementationMethods(
            packageName,
            service.name,
            service.methodList
        )
        return classBuilder
            .addFunctions(functionSpecs)
            .build()
    }

    private fun implementationMethods(
        packageName: String,
        serviceName: String,
        methods: List<DescriptorProtos.MethodDescriptorProto>
    ): List<FunSpec> {
        val functions = mutableListOf<FunSpec>()
        for (method in methods) {
            val inputClassName = ClassName.bestGuess(className(method.inputType))
            val outputClassName = ClassName.bestGuess(className(method.outputType))
            val methodCallBlock = CodeBlock.builder()
                .addStatement("MethodSpec(")
                .addStatement("\"$packageName.$serviceName/${method.name}\",")
                .indent()
                .addStatement("$inputClassName::class,")
                .addStatement("$outputClassName::class,")
                .unindent()
                .addStatement("),")
                .build()
            if (method.hasClientStreaming() && method.hasServerStreaming()) {
                val streamingFunction = FunSpec.builder(method.name.lowerCamelCase())
                    .addModifiers(KModifier.OVERRIDE)
                    .addModifiers(KModifier.SUSPEND)
                    .addParameter("headers", HEADERS_CLASS_NAME)
                    .returns(
                        BidirectionalStreamInterface::class.asClassName()
                            .parameterizedBy(
                                inputClassName,
                                outputClassName
                            )
                    )
                    .addStatement(
                        "return %L",
                        CodeBlock.builder()
                            .addStatement("client.stream(")
                            .indent()
                            .addStatement("headers,")
                            .add(methodCallBlock)
                            .unindent()
                            .addStatement(")")
                            .build()
                    )
                    .build()
                functions.add(streamingFunction)
            } else if (method.hasServerStreaming()) {
                val serverStreamingFunction = FunSpec.builder(method.name.lowerCamelCase())
                    .addModifiers(KModifier.OVERRIDE)
                    .addModifiers(KModifier.SUSPEND)
                    .addParameter("headers", HEADERS_CLASS_NAME)
                    .returns(
                        ServerOnlyStreamInterface::class.asClassName().parameterizedBy(inputClassName, outputClassName)
                    )
                    .addStatement(
                        "return %L",
                        CodeBlock.builder()
                            .addStatement("client.serverStream(")
                            .indent()
                            .addStatement("headers,")
                            .add(methodCallBlock)
                            .unindent()
                            .addStatement(")")
                            .build()
                    )
                    .build()
                functions.add(serverStreamingFunction)
            } else if (method.hasClientStreaming()) {
                val clientStreamingFunction = FunSpec.builder(method.name.lowerCamelCase())
                    .addModifiers(KModifier.OVERRIDE)
                    .addModifiers(KModifier.SUSPEND)
                    .addParameter("headers", HEADERS_CLASS_NAME)
                    .returns(
                        ClientOnlyStreamInterface::class.asClassName().parameterizedBy(inputClassName, outputClassName)
                    )
                    .addStatement(
                        "return %L",
                        CodeBlock.builder()
                            .addStatement("client.clientStream(")
                            .indent()
                            .addStatement("headers,")
                            .add(methodCallBlock)
                            .unindent()
                            .addStatement(")")
                            .build()
                    )
                    .build()
                functions.add(clientStreamingFunction)
            } else {
                val unarySuspendFunction = FunSpec.builder(method.name.lowerCamelCase())
                    .addModifiers(KModifier.SUSPEND)
                    .addModifiers(KModifier.OVERRIDE)
                    .addParameter("request", inputClassName)
                    .addParameter("headers", HEADERS_CLASS_NAME)
                    .returns(ResponseMessage::class.asClassName().parameterizedBy(outputClassName))
                    .addStatement(
                        "return %L",
                        CodeBlock.builder()
                            .addStatement("client.unary(")
                            .indent()
                            .addStatement("request,")
                            .addStatement("headers,")
                            .add(methodCallBlock)
                            .unindent()
                            .addStatement(")")
                            .build()
                    )
                    .build()
                functions.add(unarySuspendFunction)
            }
        }
        return functions
    }

    private fun className(type: String): String {
        val className = type.split(".").last()
        if (compiledTypes.contains(className)) {
            val packageName = compiledTypes[className]
            return "$packageName.$className"
        }
        return type.substring(1)
    }
}

private fun serviceClientInterfaceClassName(packageName: String, service: DescriptorProtos.ServiceDescriptorProto): ClassName {
    return ClassName(packageName, "${service.name}ClientInterface")
}

private fun serviceClientImplementationClassName(packageName: String, service: DescriptorProtos.ServiceDescriptorProto): ClassName {
    return ClassName(packageName, "${service.name}Client")
}

private fun String.lowerCamelCase(): String {
    return replaceFirstChar { char -> char.lowercaseChar() }
}

private fun String.packageToDirectory(): String {
    val dir = replace('.', '/')
    if (get(0) == '/') {
        return dir.substring(1)
    }
    return dir
}
